<?php
// Section 0: general quoting/utility functions for php

$days = array('Monday','Tuesday','Wednesday',
              'Thursday','Friday','Saturday','Sunday','Weeklong');
$dummy_string = 'XXXXX';
//all backups are prefixed with this string
$archive_pre = 'zz_archive_';

//used to safely quote strings for javascript statements like
// var aa = <?=dbl_quote("nasty\nstring with </script> in it") ? >;
//frontslash and the angle brackets are escaped so we won't
//accidentally drop out of the script with a </script> tag or the
//like.  newlines, double quotes, and backslashes are escaped for
//obvious reasons.
function dbl_quote($str) {
  return '"' . addcslashes($str,"/<>\n\\\"") . '"';
}

//escapes any string so we can put it in a web page safely (though escapes
//are not processed in javascript -- hence the above function)
//unfortunately, htmlentities() doesn't escape enough, so we have our own
//function building on it.
//start with the htmlentities translations
$html_ent_tables = get_html_translation_table(HTML_ENTITIES,ENT_QUOTES);
//add single, double "smart quotes" (like MS Word)
$html_ent_tables["\x91"] = '&#8216;';
$html_ent_tables["\x92"] = '&#8217;';
$html_ent_tables["\x93"] = '&#8220;';
$html_ent_tables["\x94"] = '&#8221;';
//untested character codes below this point
//m-dash, supposedly
$html_ent_tables["\x97"] = '&#8212;';
//single-double smart quotes again, for some reason
$html_ent_tables["\x98"] = '&#8216;';
$html_ent_tables["\x99"] = '&#8217;';
$html_ent_tables["\x8c"] = '&#8220;';
$html_ent_tables["\x9d"] = '&#8221;';

function escape_html($str,$display_all = false) {
  global $html_ent_tables;
  if ($display_all && !strlen($str)) {
    switch (true) {
    case $str === "":
      return "";
    case $str === null:
      return 'null';
    case $str === false:
      return 'false';
    }
  }
  return strtr($str,$html_ent_tables);
}

//strips slashes from form input, assuming php is quoting things with
//magic_quotes_gpc or magic_quotes_sybase, which should both die
if (!function_exists('stripformslash')) {
  if (!ini_get('magic_quotes_sybase')) {
    if (get_magic_quotes_gpc()) {
      function stripformslash($str) {
        global $first_strip;
        if (!$first_strip) {
          return $str;
        }
        if (is_array($str)) {
          return array_map('stripformslash',$str);
        }
        return stripslashes($str);
      }
    }
    else {
      function stripformslash($str) {
        return $str;
      }
    }
  }
  else {
    //quoting for database?  Man, you're stupid -- databases quote things already
    function stripformslash($str) {
      global $first_strip;
      if (!$first_strip) {
        return $str;
      }
      if (is_array($str)) {
        return array_map('stripformslash',$str);
      }
      return str_replace("''","'",$str);
    }
  }
}

//TODELETE
function escape_strip($str) {
  return escape_html($str);
}

//takes php array, returns string which, when surrounded by [ and ],
//gives a javascript array.
function js_array($arr) {
  if (isset($arr))
    return implode(', ',array_map('dbl_quote',$arr));
}

//makes a javascript associative array.  Unlike the above function, prints 
//out the full javascript, since it consists of multiple statements.  It should
//be rewritten to just return the string.
function js_assoc_array($js_var,$arr) {
  echo "var $js_var = new Array();\n";
  foreach ($arr as $key => $val) {
    echo "{$js_var}[" . dbl_quote($key) . "] = " . dbl_quote($val) . ";\n";
  }
}

//quote string that will be used in a "like" mysql query -- underscore
//and percent must be quoted.
function quote_mysqlreg($str) {
  return addcslashes($str,'_%\\');
}

//quoting function for mysql column/table names.  Called bracket for
//historic reasons.  Not usually needed, unless the table name could
//potentially have a ` character in it.
function bracket($str) {
  $str = str_replace('`','``',$str);
  return "`$str`";
}

//TODELETE
//just gives the database in brackets with a '.'.  It's here so that if we don't
//have multiple databases, this can go away
if ($USE_MYSQL_FEATURES) {
  function db_prefix($dbname) {
    return bracket($dbname) . ".";
  }
}
else {
  function db_prefix($dbname) {
    return "";
  }
}

/////// The following section is used only by table_edit.php and
/////// related scripts.

//ok, this is kind of specific to be in this section, but what we're doing here
//is figuring out on the fly which columns in a table are not real (they'll be
//generated by the php code), and which are, and thus should be selected

//called by bracketvirt below to get the columns for update_db and table_edit,
//so we know what's real and what's not.
function get_real_table_columns() {
  //remember, functions don't have access to global variables without this line
  global $col_reals;
  //do nothing if already initialized
  if (isset($col_reals)) {
    return;
  }
  global $db, $table_name;
  $col_reals = array();
  //get table info
  $res = $db->Execute("SHOW COLUMNS FROM " . bracket($table_name));
  //each column in the table is real -- any others are not
  if (is_empty($res)) {
    trigger_error("No table " . 
                  escape_html($table_name) . " in get_real_table_columns",
                  E_USER_ERROR);
  }
  while ($col_info = $res->FetchRow()) {
    $col_reals[$col_info['Field'] ] = 1;
  }
  return true;
}

//deal with non-real column names in a query -- make them '' AS col
function bracketvirt($str) {
  global $col_reals;
  if (!isset($col_reals)) {
    get_real_table_columns();
  }
  if (!array_key_exists($str,$col_reals) || !$col_reals[$str]) {
    return "'' AS " . bracket($str);
  }
  return bracket($str);
}


//these functions exist in PHP >= 5.1, but if we don't have that, they
//are defined in include files.  php_utils was defined in janakdb.inc
foreach (array('array_intersect_key','array_diff_key','stripos',
               'file_put_contents','fputcsv','strpbrk','str_split') as $func) {
  if (!function_exists($func)) {
    require_once("$php_utils/$func.php");
  }
}

///////// Some formatting functions.  Only used in a couple of scripts.

//TODELETE
function make_numeric($str) {
  settype($str,"int");
  return $str;
}

//what you think
function make_integer($str) {
  settype($str,"int");
  return $str;
}

//formats a number as a money amount
function money_table($str) {
  if (!$str) {
    return '$0';
  }
  else if ($str < 0) {
    $ret = '-';
  }
  else {
    $ret = '';
  }
  return $ret . '$' . number_format(abs($str),2);
}

//formats money for html output
function money($str) {
  return escape_html(money_table($str));
}

//abstracted here in case someone wants to change how availability is
//encoded in preference forms.  Currently, there is a flag for each
//hour between 8 am and midnight, with 0 through 4 meaning desired,
//available, don't want, can't do, and don't know.  The corresponding
//encode_avail is not currently needed, since the only script that
//encodes availability (record_prefs.php) has no include files at that
//stage, for the fewest possible errors.  Used in preferences.php,
//record_prefs.php, and show_prefs.php
//the encoding just looks at the digit at the $jj-th place, adjusted
//for initial zeros.
$av_options = array('+','','-','x','?');
function decode_avail($av,$jj) {
  if (16-strlen($av) > $jj) {
    return 0;
  }
  //there is a test here to see if the return value is greater than 0
  //because old preferences may have used a different encoding.  To
  //avoid fatal errors, we just ignore this.  It shouldn't be a
  //problem, since the encoding is now consistent, but just in case.
  return ($val = substr($av,$jj-16+strlen($av),1)) > 4?0:$val;
}

//formatted workshift
function format_shift($shift,$hours,$floor='') {
  return $shift . ($floor? ' ' . $floor:'') .
    ' (' . $hours . ')';
}

//End Section 0: utility functions

//Section 1: sql functions that communicate with the sql server.  They
//mostly do fairly trivial things, but they are encapsulated here for
//two reasons.  The first is that this way, people can change things
//like the structure of tables slightly more easily.

//input can be recordset or 2-d array
function is_empty($res) {
  return !($res && ((is_object($res) && !$res->EOF) || 
		    (is_array($res) && count($res))));
}

function table_exists($tbl) {
  global $db,$archive;
  return (!is_empty($db->GetRow("show tables like '" . 
                                quote_mysqlreg($archive . $tbl) . "'")));
}

//Checking for global users (sysadmin, etc.)
function check_admin_priv($member_name, $passwd, $priv=-1) {
  //file is in the php_includes path
  global $php_includes;
  //if we've already checked this person, return it
  static $rets = array();
  if (isset($rets[$member_name])) {
    return ($priv == -1 || $rets[$member_name] == $priv);
  }
  static $user_privs = null;
  if (!isset($user_privs)) {
    $user_privs = array();
    //get the file in lines
    $temp_privs = explode("\n",file_get_contents("$php_includes/user_privs"));
    //for each line, store it away
    for ($ii = 0; $ii < count($temp_privs); $ii++) {
      $privline = explode("c\r\t\rd",$temp_privs[$ii]);
      $user_privs[] = $privline;
    }
  }
  foreach ($user_privs as $privline) {
    if (count($privline) < 3) {
      break;
    }
    if (crypt($member_name,$privline[0]) == $privline[0] &&
        crypt($passwd,$privline[1]) == $privline[1] &&
        ($priv == -1 || crypt($priv,$privline[2]) == $privline[2])) {
      $rets[$member_name] = $priv;
      return true;
    }
  }
  return false;
}

//see if user-entered password matches.  Negative values are for
//errors, 0 for non-matching, and 1 for success.  We return -3 for no
//proper input, -2 if the user is not in the house list, -1 if there
//is no set password, -4 if there is no set password but the user entered one.
//  null is returned if the sql query has an error
function check_passwd($member_name = null, $passwd = null) {
  global $db, $main_db, $url_name;
  if (!$member_name) {
      if (!array_key_exists('member_name',$_REQUEST)) {
        return -3;
      }
      $member_name = $_REQUEST['member_name'];
    }
    if (!$passwd && array_key_exists('passwd',$_REQUEST)) {
      $passwd = $_REQUEST['passwd'];
    }
    //hack to let the administrator view any user page, for debugging.
    if (check_admin_priv($member_name,$passwd)) {
      return 1;
    }
    //does this member exist?
    $row = $db->GetRow("SELECT COUNT(*) as `res` FROM `house_list`" .
                       " WHERE `member_name` = ?",
                       array($member_name));
    if (is_empty($row)) {
      return null;
    }
    //what was the value?
    if (make_numeric($row['res']) <= 0) {
      return -2;
    }
    $row = $db->GetRow("SELECT `passwd` FROM `password_table` " . 
                       "WHERE `member_name` = ?",
                       array($member_name));
    //no password set AND user didn't enter a password this time?
    if ((is_empty($row) || !$row['passwd']) && !$passwd) {
      return -1;
    }
    if (is_empty($row) || !$row['passwd']) {
      return -4;
    }
    //hash up our password -- password are stored hashed.
    $row2 = $db->GetRow("select password(?) as pw",array($passwd));
    return make_numeric($row['passwd'] == $row2['pw']);
}

//set the password.  Password can be set if it hasn't been set yet, or
//if oldpasswd matches.  Called in record_prefs.php and
//set_passwd.php.  Hashes up password so snooping administrators can't
//find it out.
function set_passwd($member_name, $newpasswd,$oldpasswd) {
  global $db;
  $check_res = check_passwd($member_name,$oldpasswd);
  if ($check_res == -1 || $check_res == -4 || $check_res > 0) {
    return $db->Execute("REPLACE INTO `password_table` " .
                        "(`member_name`,`passwd`) VALUES (?,PASSWORD(?)) ",
                        array($member_name,$newpasswd));
  }
  return false;
}

//just encapsulated for ease of use
function get_email($member_name) {
  global $db;
  $email_row = $db->GetRow("select `email` from `house_info` " .
                            "where `member_name` = ?",
                            array($member_name));
  if (!is_empty($email_row)) {
    return $email_row['email'];
  }
  return null;
}

/////////  Create functions.  Most have been moved to
//create_all_tables.php, but the ones that actually need to be called
//each time by scripts (as opposed to only once in the history of the
//database) are here.

//weekly_totals_data is a monster of a table which needs to always
//have the right number of columns, one for each week, etc.  It has an
//"owed hours" column for each week, so that each member's obligation
//for a given week can be changed.  Because the table's definition
//depends on user-set parameters, it is created here, as opposed to in
//create_all_tables.php
function create_and_update_weekly_totals_data() {
  global $db,$archive;
  static $done = false;
  if (!$done) {
    $this_tbl = bracket($archive . 'weekly_totals_data');
    //how many columns of weeks?
    $tot_weeks = get_static('tot_weeks',18);
    //what should the owed default be?
    $owed_default = get_static('owed_default',5);
    if (!table_exists('weekly_totals_data')) {
      //make a sql create_table command
      $cols = '';
      for ($ii = 0; $ii <= $tot_weeks; $ii++) {
        $cols .= "`owed $ii` float not null default $owed_default, ";
      }
      $done = $db->Execute("CREATE TABLE if not exists $this_tbl " .
                           '(`autoid` INT(11) AUTO_INCREMENT, ' . 
                           '`member_name` VARCHAR(50) not null, ' .
                           $cols . 
                           '`notes` LONGTEXT default null, ' .
                           'PRIMARY KEY (`autoid`), ' .
                           'UNIQUE KEY `member_name` (`member_name`))');
    }
    else {
      //does the table have the right number of columns?
      $res = $db->Execute("show columns from $this_tbl");
      $ii = -3;
      //I forget where, but we must get called somewhere while we're
      //in ADODB_FETCH_NUM mode, meaning that the columns are
      //numerically indexed, not by name
      $oldfetch = $db->fetchMode;
      $db->SetFetchMode(ADODB_FETCH_ASSOC);
      $alter_cols = '';
      //look at all the columns we currently have, and see if any have
      //the wrong defaults.  This won't change anyone's currrently
      //owed hours, just the defaults for new people.
      $firstflag = true;
      while ($row = $res->FetchRow()) {
        $ii++;
        switch ($row['Field']) {
        case 'autoid': case 'member_name': case 'notes':
          continue;
        default:
          if ($row['Default'] != $owed_default) {
            if (!$firstflag) {
              $alter_cols .= ',';
            }
            else {
              $firstflag = false;
            }
            $alter_cols .= " alter column `{$row['Field']}` " .
              "set default $owed_default ";
          }
        }
      }
      //now we've gone through all the columns we had.  How many more
      //do we have to add?
      $add_cols = '';
      for (; $ii <= $tot_weeks; $ii++) {
        $add_cols .= " `owed $ii` float not null default $owed_default";
        if ($ii < $tot_weeks) {
          $add_cols .= ",";
        }
      }
      if ($add_cols) {
        $add_cols = 'add column (' . $add_cols . ')';
      }
      if ($add_cols || $alter_cols) {
        $done = $db->Execute("alter table $this_tbl " . 
                             $alter_cols . $add_cols);
      }
    }
    /*    //we have a nicely updated table, but now we have to put in all
    //the members who might have recently been added.  This should
    //never happen, because update_house.php should take care of it.
    //the sql query is structured so that we get those member_names
    //from the house_list which are not in weekly_totals_data already
    //(so their join is null)
    $hs_tbl = bracket($archive . 'house_list');
    $done &= $db->Execute(<<<SYNCDATA
insert into $this_tbl (`member_name`) select 
$hs_tbl.`member_name` from $hs_tbl left join $this_tbl 
on $hs_tbl.`member_name` = $this_tbl.`member_name` 
where $this_tbl.`member_name` is null
SYNCDATA
                          );
    //we just modified the table, or maybe, anyway
    set_mod_date('weekly_totals_data');
    */
  }
  return $done;
}

//unfortunately, older versions of mysql don't have views or
//subqueries, which are essential for totalling hours from multiple
//weeks.  Thus, we resort to keeping track of the totals for each week
//in a totals table.  This table needs to be updated whenever the week
//or the house list is updated.  Note that for efficiency, it does not
//update weekly_totals_data, even though it depends on it for the
//autoid and member_name.  Thus, callers must call
//create_and_update_weekly_totals_data beforehand.
function create_and_update_week_totals($ii) {
  global $db,$archive;
  //not static, because this could conceivably be called before and
  //after a modification of a week page
  $done = true;
  //we don't want get_mod_date to set the mod_date of the totals table
  //to now, we want it to return 0, meaning never modified, because
  //that means the table is missing, and we need to create it
  if (get_mod_date("week_$ii",false) > 
      get_mod_date("week_$ii" . "_totals",true) ||
      get_mod_date("house_list",false) > 
      get_mod_date("week_$ii" . "_totals",true)) {
    $tot_tbl = bracket("{$archive}weekly_totals_data");
    $wk_tbl = bracket("{$archive}week_$ii");
    //the totals we keep track of are the done hours (all the
    //positives), the blown (all the negatives), and the grand total.
    //Unfortunately, if someone didn't do any shifts one week, their
    //sum will be null, so we have to use the ifnull function
    $sel_statement = <<<SELECT
select $tot_tbl.`autoid`, $tot_tbl.`member_name`,
ifnull(sum(greatest(0,hours)),0) as `done`,
ifnull(sum(least(0,hours)),0) as `blown`,
ifnull(sum(hours),0) as `tot`
from $tot_tbl left join ($wk_tbl)
on ($wk_tbl.`member_name` = $tot_tbl.`member_name`)
group by `member_name` order by `member_name`
SELECT
;
    $this_tbl = bracket("{$archive}week_{$ii}_totals");
    $done &= $db->Execute(
<<<CREATETABLE
create table if not exists $this_tbl
(`autoid` int(11) not null auto_increment,
 `member_name` varchar(50) not null default '',
 `done` double not null default '0',
 `blown` double NOT NULL default '0',
 `tot` double NOT NULL default '0',
 primary key (autoid), unique (member_name))
CREATETABLE
);
    $done &= $db->Execute("delete from $this_tbl");
    $done &= $db->Execute("insert into $this_tbl " . $sel_statement);
    set_mod_date("week_" . $ii . "_totals");
  }
  return $done;
}
    
function create_and_update_fining_data_totals() {
  global $db,$archive;
  $done = true;
  if (get_mod_date("fining_data",false) > 
      get_mod_date("fining_data_totals",true)) {
    $done &= create_and_update_weekly_totals_data();
    $this_tbl = bracket($archive . 'fining_data_totals');
    $tot_tbl = bracket($archive . 'weekly_totals_data');
    $fin_tbl = bracket($archive . 'fining_data');
    $done &= $db->Execute("delete from $this_tbl");
    $done &= $db->Execute("insert into $this_tbl " .
                          "select null, $tot_tbl.`member_name`, " .
                          "sum(`fine`) from " .
                          "$tot_tbl left join $fin_tbl " .
                          "using (`member_name`) " .
                          "group by `member_name` " .
                          "order by `member_name`");
    set_mod_date('fining_data_totals');
  }
  return $done;
}

//the master_week needs to be regenerated every time master_shifts
//changes and we create a new weekly sheet
function update_master_week() {
  global $db,$days,$archive;
  //the <= is because master_week should be younget
  if (get_mod_date('master_week') <= 
      get_mod_date('master_shifts')) {
    $this_tbl = bracket($archive . 'master_week');
    $db->Execute("delete from $this_tbl");
    foreach ($days as $day) {
      $db->Execute("insert into $this_tbl " . 
                   query_day($day,null));
    }
  }
  set_mod_date('master_week');
}

//utility function to get all the shifts done on a given day
function query_day($day,$week_date = null) {
  global $db, $dummy_string,$days,$archive;
  //print out the literal day, along with the nicely formatted shift
  //name, the person doing the shift, and the hours it's worth, so
  //long as someone actually should be doing the shift (the person is
  //not the dummy string) also, if we're using this to actually
  //generate weekly sheet, output the date the shift is done on
  if ($week_date) {
    $num = array_search($day,$days);
    if ($num == 7) {
      $num = 6;
    }
    else if (!$num) {
      $num = 0;
    }
  }
  return "SELECT " .
    ($week_date ? 
     "null as `autoid`, " .
     "ADDDATE('$week_date',interval $num day) as `date`, ":"") .
    "'$day' AS `day`, " .
    "concat(`workshift`,if(`floor`,concat(' ',`floor`),'')) " .
    "AS `workshift`, `$day` AS  `member_name`, `hours` AS `hours`, " .
    "`autoid` as `shift_id`, `start_time`, `end_time` " .
    "FROM " . bracket("${archive}master_shifts") .  
    " WHERE not (`$day` <=> '$dummy_string')";
}

////// Utility functions, printing, getting, setting.  Useful stuff.

//get global variables stored in sql table.  The variables are stored in
//a table which is per-database, so every database has its own static
//variables, and they are completely different namespaces.  get_static
//just acts on the active database
function get_static($var_name, $default_value=null) {
  global $db,$archive;
  $row = $db->GetRow('SELECT `var_value` FROM ' . 
		     bracket($archive . 'static_data') .
		     ' WHERE `var_name` = ?', 
		     array($var_name));
  if (is_empty($row)) {
    if ($default_value !== null) {
      set_static($var_name,$default_value,$archive);
    }
    return $default_value;
  }
  return ($db->fetchMode == ADODB_FETCH_ASSOC?$row['var_value']:$row[0]);
}

//set global config
function set_static($var_name,$var_value,$dummyarchive='') {
  global $db,$archive;
  return ($db->Execute('REPLACE INTO ' . 
		       bracket($archive . 'static_data') . 
		       ' (`var_name`,`var_value`) VALUES (?,?)', 
                       array($var_name,$var_value)));
}

//return the current week, either the manually set one, or the one
//calculated from the start of the semester, adjusted to make sure
//that we have existing weekly sheets.  Note that cur_week is a bit of
//a misnomer -- it is actually the last completed week.  Thus, if we
//are in Wednesday of week 7, this will return 6, because it is the
//last completed week.  Returns -2 if the start of the semester hasn't
//been set.
function get_cur_week() {
  global $db,$archive;
  //has the week been set manually?
  $week_num = get_static('cur_week');
  if (!is_numeric($week_num)) {
    //current week is time now - time of semester start, divided by 
    //seconds in a week, rounded down. strtotime takes a string and
    //turns it into a timestamp
    $sem_start = get_static('semester_start');
    if (is_null($sem_start) || $sem_start === '') {
      return -2;
    }
    $week_num = floor((time()-strtotime($sem_start))/(60*60*24*7));
  }
  else {
    //add one because I think the user wants results *through* week x
    $week_num += 1;
  }
  //how many weeks are there in this semester anyway?
  if ($tot_weeks = get_static('tot_weeks')) {
    $week_num = min($week_num,$tot_weeks+1);
  }
  //we can't be past a week for which a sheet doesn't yet exist
  for ($ii = 0; $ii < $week_num; $ii++) {
    if (!table_exists("week_$ii")) {
      return $ii;
    }
  }
  return $week_num;
}

//get a houselist
function get_houselist() {
  global $db, $archive;
  $res = $db->Execute('SELECT `member_name` FROM ' . 
                      bracket($archive . 'house_list'));
  $houselist = array();
  while ($row = $res->FetchRow()) {
    $houselist[] = $row['member_name'];
  }
  return $houselist;
}

//get a list of all the backups, without the backup prefix, for
//deletion, recovery, etc.
function get_backup_dbs() {
  global $db,$archive_pre;
  //"show tables like " gives awful column names, so we go numeric
  $oldfetch = $db->fetchMode;
  $db->SetFetchMode(ADODB_FETCH_NUM); 
  //every backup should have a house list 
  $res = $db->Execute("show tables like ?",array('%\_house\_list'));
  $dbnames = array();
  //get the names without the archive prefix or the house_list
  while ($row = $res->FetchRow()) {
    $dbnames[] = substr($row[0],strlen($archive_pre),
                        -1*strlen('_house_list'));
  }
  $db->SetFetchMode($oldfetch);
  return $dbnames;
}

//extremely useful, underused function -- can put any table_edit-style
//query out as a csv file.
function export_csv_file($table_name,$query=null ,$col_formats = null, 
                         $callback=null) {
  global $db;
  //get everything if no query given
  if (!$query) {
    if (!table_exists($table_name)) {
      janak_error(escape_html($table_name) . " doesn't exist!");
      return;
    }
    $query = "select * from " . bracket($table_name);
  }
  //no output allowed before a header sent!
  header('Content-type: text/csv');
  // we want the user to save this, not open it.
  header('Content-Disposition: attachment; filename="' . 
         $table_name . '.csv"');
  $tblres = $db->Execute($query);
  //fputcsv needs a file handle, so we open stdout as a file
  $handle = fopen("php://output",'w');
  //put out the column names
  if (!$col_formats) {
    fputcsv($handle,array_keys($tblres->fields));
  }
  else {
    fputcsv($handle,array_keys($col_formats));
  }
  $num_rows = 0;
  //duplicate the table_edit loop, calling a callback on the whole
  //row, and then formatting functions on each cell.  Of course things
  //are simplified since we're not putting out html.
  while ($row = $tblres->FetchRow()) {
    if ($callback) {
      $callback($row);
    }
    $newrow = array();
    if ($col_formats) {
      $jj = 0;
      foreach ($col_formats as $col => $format) {
        $newrow[$col] = $row[$col];
        if (!isset($format) || !is_string($format) || !$format || 
            !function_exists($format) || empty($format)) {
          $format = $col_formats[$col] = '';
        }
        else {
          $newrow[$col] = $format($newrow[$col],$num_rows,$jj);
          if (is_array($newrow[$col])) {
            $newrow[$col] = $newrow[$col][0];
          }
        }
        $jj++;
      }
    }
    fputcsv($handle,$newrow);
    $num_rows++;
  }
  fclose($handle);
}

//incredibly useful time function.  Puts out a date in the user's time
//zone.  The user's time zone is guessed by some javascript code.
//Both this function and the next have to set the environment variable
//TZ, which could be problematic.
function user_time($timestamp = null,$format = null) {
  $tz_user = get_static('tz_user',null);
  //will output in any date format, but here's the default
  //12-hour:minute am/pm on day-of-week
  if (!$format) {
    $format = "g:i a \o\\n l";
  }
  if ($tz_user) {
    $oldtz = getenv("TZ");
    putenv("TZ=" . escapeshellcmd($tz_user));
  }
  if ($timestamp) {
    return date($format,$timestamp);
  }
  else {
    return date($format);
  }
  if ($tz_user || isset($oldtz)) {
    putenv("TZ=" . escapeshellarg($oldtz));
  }
}

//from a date-time in the user's time zone, get a timestamp.
function user_timestamp($sec,$min,$hr,$day,$mo,$yr) {
  $tz_user = get_static('tz_user',null);
  if ($tz_user) {
    $oldtz = getenv("TZ");
    putenv("TZ=" . escapeshellcmd($tz_user));
  }
  $retval = mktime($hr,$min,$sec,$mo,$day,$yr);
  if ($tz_user || isset($oldtz)) {
    putenv("TZ=" . escapeshellarg($oldtz));
  }
  return $retval;
}

//Section 2: php functions

//Puts a help link at top of each admin page, when called
function print_help($section=null,$span=false) {
  global $real_username,$bug_report_url,$feature_request_url,$project_url;
  //public_utils has no help file, so we have to link back to admin
  $public_utils = split('/',$_SERVER['REQUEST_URI']);
  if (count($public_utils) > 2 &&
      $public_utils[count($public_utils)-2] == 'public_utils') {
    $public_utils = true;
  }
  else {
    $public_utils = false;
  }
  print "<" . ($span?'span':'div') . 
    " class='help_link print_hide'><a href='" .
    ($public_utils?'../admin/':'') . "help.html#" . 
    escape_html($section?$section:script_name())  . 
    "' target='workshift_help'>Help</a> " .
    "<a href='" .
    escape_html($bug_report_url) .
    "'>Submit Bug</a>&nbsp;&nbsp;<a href='" .
    escape_html($feature_request_url) .
    "'>Submit Feature Request</a>&nbsp;&nbsp;<a href='" .
    escape_html($project_url) .
    "'>Sourceforge Project Page</a></" .
    ($span?'span':'div') . ">";
}

//archived private tables shouldn't become public -- check the part
//without the archive prepend
function check_tablename($arr,$tbl) {
  foreach ($arr as $key => $val) {
    if (substr($tbl,-1*strlen($key)) === $key) {
      return true;
    }
  }
  return false;
}

//does the current user have permission to view/edit/update this table?
function access_table($tbl) {
  global $table_permissions;
  if ((array_key_exists('table_allow',$table_permissions) &&
       $table_permissions['table_allow'] &&
       !check_tablename($table_permissions['table_allow'],$tbl)) ||
      (array_key_exists('table_deny',$table_permissions) &&
       $table_permissions['table_deny'] &&
       check_tablename($table_permissions['table_deny'],$tbl))) {
    return false;
  }
  return true;
}

//trivial function, just abstracted here
function get_username() {
  global $url_name;
  return $url_name . 'laborczar';
}

//what is the actual username being used to access the site?
function get_real_username() {
  $username = null;
  //if php is not in safe mode, then we get the username from php
  if (array_key_exists('PHP_AUTH_USER',$_SERVER)) {
    $username = $_SERVER['PHP_AUTH_USER'];
  }
  //maybe we'll get it from the apache environment
  if (!$username && array_key_exists('REMOTE_USER',$_SERVER)) {
    $username = $_SERVER['REMOTE_USER'];
  }
  return $username;
}

function admin_email() {
  global $admin_email;
  return "<a href='mailto:$admin_email'>$admin_email</a>";
}

//name of the script, without .php or path
function script_name() {
  return substr(end(explode('/',$_SERVER['SCRIPT_NAME'])),0,-4);
}

//for form actions
function this_url() {
  return escape_html($_SERVER['REQUEST_URI']);
}

/////  My error-handling section.

//this function should be called more.  It gets all the error messages
//it can, and then triggers an error with them.
function janak_error($str) {
  global $db, $MYSQL_VERSION;
  //get the best error message we can
  $dberr = $db->ErrorMsg();
  //maybe the error message was just a warning (because it happened
  //in a stored procedure, say), so it didn't make it out
  if (!strlen($dberr)) {
    //get all the warnings from the sql server if the version allows
    if ($MYSQL_VERSION > 41000) {
      $res = $db->Execute("SHOW WARNINGS");
      while ($row = $res->FetchRow()) {
        $dberr .= $row['Level'] . ' ' . 
          $row['Code'] . ': ' . $row['Message'];
      }
    }
  }
  //fail the transaction, if there's transactional support
  $db->CompleteTrans(false);
  if ($dberr) {
    $str .= "<br>\nDatabase error: $dberr<br>\n";
  } 
  trigger_error($str,E_USER_ERROR);
}

//change the error_reporting level, but store it in an auxilary
//variable, since adodb is going to try to change it on its own, and
//we will have to ignore the error level then, and go by our variable.
function janak_error_reporting($errlevel = null) {
  global $janak_error_reporting_level;
  $tmp = $janak_error_reporting_level;
  if ($errlevel !== null) {
    $janak_error_reporting_level = $errlevel;
    error_reporting($errlevel);
  }
  return $tmp;
}

//there are errors you report, and there are errors you die on.
function janak_fatal_error_reporting($errlevel = null) {
  global $janak_fatal_error_level;
  $tmp = $janak_fatal_error_level;
  if ($errlevel !== null) {
    $janak_fatal_error_level = $errlevel;
  }
  return $tmp;
}

//this function replaces the php error handler.  It puts out what
//is hopefully a friendly-ish message to users, but also puts out
//hidden html with more details, so debugging is easier.  Currently
//the message to users might be a little scary, because I want them to
//email me with the message.
function janak_errhandler($errno,$errstr,$errfile,
                          $errline,$errcontext) {
  global $user_errmsg, $admin_email, $house_name,$bug_report_url;
  if (!($errno & janak_error_reporting()) &&
      !($errno & janak_fatal_error_reporting())) {
    return;
  }
  $script_name = script_name();
  print("<h3>Sorry, there was an error.  " .
        "You can check the <a href='help.html#" .
        escape_html($script_name) . 
        "' target='workshiftdb_help'>general helpfile</a>.  Please <a href='" .
        escape_html($bug_report_url) .
        "'>submit a bug report</a>.  You can also email the administrator (" .
        admin_email() . ") with the url of the page you're at, (in the " .
        "address bar) and the following message.  </h3><p>");
  if ($errno & janak_error_reporting()) {
    //the error string is printed out, but the full backtrace is
    //hidden from the users, unless they view source
    print($errstr . "<!--\n(In " . basename($errfile) . 
          " on line $errline.  ");
    $arr = debug_backtrace();
    ob_start();
    while (count($arr) > 1) {
      $outer = $arr[count($arr)-1];
      print("\nCalled in " . basename($outer['file']) . 
            ' on line ' . $outer['line']);
      array_pop($arr);
    }
    $str = ob_get_clean();
    print $str;
    print (")-->\n");
  }
  elseif ($user_errmsg) {
    print($user_errmsg);
  }
  $old_rep = janak_error_reporting(0);
  $old_fat = janak_fatal_error_reporting(0);
  ob_start();
  print "error: ";
  var_dump($errstr);
  print "\npage: " . this_url() . "\nerrno: ";
  var_dump($errno);
  if (isset($str)) {
    print "\nDebug backtrace:";
    print($str);
  }
  print "\nerrfile: ";
  var_dump($errfile);
  print "\nerrcontext: ";
  var_dump($errcontext);
  print "Globals:\n";
  print_r($GLOBALS);
  print "\nEND GLOBALS\n";
  print "var_dump Globals";
  var_dump($GLOBALS);
  print "\nEND var_dump GLOBALS\n";
  $arr = debug_backtrace();
  print_r($arr);
  $str = ob_get_clean();
  if (!mail($admin_email,"Workshift db error, $house_name in " .
            basename($errfile) . " at $errline",$str)) {
    print "Couldn't email administrator $admin_email";
  }
  janak_error_reporting($old_rep);
  janak_fatal_error_reporting($old_fat);
  if ($errno & janak_fatal_error_reporting()) {
    exit;
  }
} 

//Functions so we know whether tables are up-to-date

function get_mod_date($tbl,$tell_missing = true) {
  global $db,$archive;
  $row = $db->GetRow("select unix_timestamp(`mod_date`) as `mod_date`" .
                     " from " . bracket("{$archive}modified_dates") .
                     " where `table_name` = ?",
                     array($tbl));
  if (is_empty($row)) {
    if ($tell_missing) {
      return 0;
    }
    set_mod_date($tbl);
    $row = $db->GetRow("select unix_timestamp(`mod_date`) " .
                       "as `mod_date` from " .
                       bracket($archive . 'modified_dates') .
                       " where `table_name` = ?",
                       array($tbl));
  }
  return $row['mod_date'];
}

function set_mod_date($tbl,$timestamp = null) {
  global $db,$archive;
  if ($timestamp === null) {
    $db->Execute("replace into " .
                 bracket("{$archive}modified_dates") .
                 " values (null,?,now())",
                 array($tbl));
  } 
  else {
    if ($timestamp{4} != '-') {
      $timestamp = date('Y-m-d H:i:s',$timestamp);
    }
    $db->Execute("replace into " .
                 bracket("{$archive}modified_dates") .
                 " values (null,?,?)",
                 array($tbl,$timestamp));
  }
}

//Functions which allow us to customize pieces of text.
//This lets workshift managers modify text to be what they want.
//For each piece of text, specified wildcards are allowed.
function get_static_text($text_name,$def_val = null,
                         $escape_seqs = array(),$is_html = null,$prestyle = null) {
  global $db,$archive;
  $row = $db->GetRow('SELECT `text_value`, `is_html`, `escape_seqs` ' .
		     'FROM ' . 
		     bracket($archive . 'static_text') .
		     ' WHERE `text_name` = ?', 
		     array($text_name));
  if (is_empty($row)) {
    if ($def_val !== null) {
      set_static_text($text_name,$def_val,$is_html,$escape_seqs);
    }
    else {
      return null;
    }
    $row['text_value'] = $def_val;
    //escape_seqs is an array, and we're about to unserialize it
    $row['escape_seqs'] = serialize($escape_seqs);
    $row['is_html'] = $is_html;
  }
  //make array
  $escape_seqs = unserialize($row['escape_seqs']);
  //the key is the wildcard, the value is an array with replacement
  //expression and then the description of the wildcard.
  foreach ($escape_seqs as $esc => $seq) {
    $seq = $seq[1];
    //if the replacement starts with '*' it means we have to
    //execute it as php code.  This is safe since users don't get
    //to specify the code, only that it is to be executed.
    if (is_string($seq) && strlen($seq) && $seq{0} == '*') {
      $seq = substr($seq,1);
      //set $seq to the result of the code.
      eval("\$seq = $seq;");
    }
    else {
      //if $seq is a string, it is just a variable
      if (!is_array($seq)) {
        $seq = $GLOBALS[$seq];
      }
      //oh, but maybe it's buried in an array, so we have to descend.
      else {
        $temp = $GLOBALS;
        foreach ($seq as $ind) {
          if (array_key_exists($ind,$temp)) {
            $temp = $temp[$ind];
          }
          else {
            break;
          }
        }
        $seq = $temp;
      }
    }
    //replace $esc with $seq
    $row['text_value'] = str_replace($esc,$seq,$row['text_value']);
  }
  //if it's html (or, more precisely, if it shouldn't be escaped)
  //output as is
  if ($row['is_html']) {
    return $row['text_value'];
  }
  else {
    if ($prestyle) {
      $ret = "<div style='" . white_space_css() . "'>";
    }
    else {
      $ret = '';
    }
    $ret .= escape_html($row['text_value']);
    if ($prestyle) {
      $ret .= "\n</div>";
    }
    return $ret;
  }
}

function set_static_text($text_name,$text_value = null,
                         $is_html = null,$escape_seqs = array()) {
  global $db,$archive;
  if ($is_html === null) {
    $row = $db->GetRow("select `is_html` from " .
                        bracket($archive . 'static_text') .
                        " where `text_name` = ?",
                        array($text_name));
    if (!is_empty($row)) {
      $is_html = $row['is_html'];
    }
  }
  if (!count($escape_seqs)) {
    $row = $db->GetRow("select `escape_seqs` from " .
                        bracket($archive . 'static_text') .
                        " where `text_name` = ?",
                        array($text_name));
    if (!is_empty($row) && strlen($row['escape_seqs'])) {
      return $db->Execute('update ' . 
                          bracket($archive . 'static_text') . 
                          ' set `text_value` = ?,`is_html` = ? where ' .
                          '`text_name` = ?',
                          array($text_value,$is_html,$text_name));
    }
  }
  return $db->Execute('REPLACE INTO ' . 
                      bracket($archive . 'static_text') . 
                      ' (`text_name`,`text_value`,`escape_seqs`,' .
                      '`is_html`) VALUES (?,?,?,?)', 
                      array($text_name,$text_value,
                            serialize($escape_seqs),$is_html));
}

//utility function, since usually we'll be printing static_text out.
function print_static_text($text_name,$def_val = null, 
                           $escape_seqs = array(), $is_html = null,$prestyle = null) {
  print get_static_text($text_name,$def_val,$escape_seqs,$is_html,$prestyle);
}

//sometimes we need to get the raw text, guaranteed no quoting.
//complication comes in that maybe we haven't initialized yet.
function get_raw_static_text($text_name,$def_val = null,
                             $escape_seqs = array(),$is_html = 0) {
  global $db,$archive;
  $row = $db->GetRow('SELECT `text_value` FROM ' . 
		     bracket($archive . 'static_text') .
		     ' WHERE `text_name` = ?', 
		     array($text_name));
  if (is_empty($row)) {
    if ($def_val !== null) {
      set_static_text($text_name,$def_val,$is_html,$escape_seqs);
      return $def_val;
    }
    else {
      return null;
    }
  }
  return $row['text_value'];
}

//get the escape arguments.  Each escape code has two vals, the description
//and the 
function get_escapes_text($text_name) {
  global $db,$archive;
  $row = $db->GetRow('select `escape_seqs` from ' .
                     bracket($archive . 'static_text') .
                     ' where `text_name` = ?',
                     array($text_name));
  if (is_empty($row)) {
    return array();
  }
  $ret = unserialize($row['escape_seqs']);
  foreach ($ret as $key =>$vals) {
    $ret[$key] = $vals[0];
  }
  return $ret;
}

function get_is_html_text($text_name) {
  global $db, $archive;
  $row = $db->GetRow('select `is_html` from ' .
                     bracket($archive . 'static_text') .
                     ' where `text_name` = ?',
                     array($text_name));
  if (is_empty($row)) {
    return null;
  }
  return $row['is_html'];
}

// Election functions

//get an attribute of an election (number of candidates, end date,
//etc.  If this attribute is the attribute of a particular race in the
//election, specify the race in for_race
function get_election_attrib($attrib,$for_race=true) {
  global $db,$election_name,$race_name;
  $sqlargs = array($attrib,$election_name);
  if ($attrib == 'race_name') {
    $row = $db->GetRow("select `race_name` as `attrib_value` from `elections_attribs` " .
                       "where `attrib_name` = 'race_name' and " .
                       "`autoid` = ? and `election_name` = ?",
                       array($for_race,$election_name));
    if (is_empty($row)) {
      janak_error("Race " . escape_html($for_race) . " does not exist");
    }
    return $row['attrib_value'];
  }
  if ($for_race) {
    $sqlargs[] = $race_name;
  }
  $row = $db->GetRow('SELECT `attrib_value` FROM `elections_attribs` ' .
                     ' WHERE `attrib_name` = ? and ' .
                     '`election_name` = ?' . 
                     ($for_race?' and `race_name` = ?':''),
                     $sqlargs);
  return $row['attrib_value'];
}

//To help prevent elections fraud, this function is called to log any
//potentially suspicious activity.  Most of the fields' meanings
//depend on the particular action being logged.
function elections_log($election_name,$subj_name,$attrib,$oldval,$val) {
  global $db;
  //store arrays serialized -- only way to store them
  if (is_array($oldval)) {
    $oldval = serialize($oldval);
  }
  if (is_array($val)) {
    $val = serialize($val);
  }
  return $db->Execute("insert into `elections_log` " .
                      "(`time_entered`,`election_name`," .
                      "`subj_name`,`attrib`,`oldval`,`val`) " .
                      "values (now(),?,?,?,?,?)",
                      array($election_name,$subj_name,
                            $attrib,$oldval,$val));
}

//////// Access and authorization functions, used mostly for elections

//the privileges so far are workshift, house, president, and nonvoter.
//The first two are not operational.  The last two are.  nonvoters
//can't vote -- that's the only effect of their "privilege."
//Privileges are stored as a comma-separated list, indexed by member.

//is this user of this type?
function authorized_user($member_name,$type) {
  global $db;
  $attribs = user_privileges($member_name);
  return in_array($type,$attribs);
}

//what are all the privileges this user has?
function user_privileges($member_name) {
  global $db;
  $attribs = $db->GetRow("select `privileges` " .
                         "from `privilege_table` where " .
                         "`member_name` = ?",
                         array($member_name));
  //let the administrator into everything.
  if (check_admin_priv($member_name,null,0)) {
    return array('president','workshift','house');
  }
  if (is_empty($attribs)) {
    return array();
  }
  return explode(',',$attribs['privileges']);
}

//what privileges can the user grant to others?  Usually, a user can
//grant only their own privilege, except that the president can make
//people into nonvoters, and thus unable to vote.
function user_grant_privileges($member_name) {
  global $db;
  $attribs = user_privileges($member_name);
  $ret = array();
  foreach ($attribs as $attrib) {
    if ($attrib == 'president') {
#      $ret[] = 'workshift';
#      $ret[] = 'house';
      $ret[] = 'nonvoter';
    }
    //nonvoters can't make other people nonvoters
    if ($attrib == 'nonvoter') {
      continue;
    }
    $ret[] = $attrib;
  }
  return $ret;
}

//who are the people with this privilege?
function users_with_privileges($type) {
  global $db;
  $res = $db->Execute("select * from `privilege_table`");
  $ret = array();
  while ($row = $res->FetchRow()) {
    $attribs = explode(',',$row['privileges']);
    if (in_array($type,$attribs)) {
      $ret[] = $row['member_name'];
    }
  }
  return $ret;
}

//add/remove a privilege from a user.
function add_authorized_user($mem_name,$type) {
  global $db,$member_name;
  //we can't alter privileges for someone not in the house
  if (!in_array($mem_name,get_houselist())) {
    return null;
  }
  //are they already in this type?  Get rid of them
  if (authorized_user($mem_name,$type)) {
    //here are their new privileges
    $privs = array_diff(user_privileges($mem_name),array($type));
    //changing privileges is a suspicious activity
    elections_log(null,$mem_name,$member_name,
                  user_privileges($mem_name),
                  $privs);
    return $db->Execute("insert into `privilege_table` (`member_name`," .
                        "`privileges`) values (?,?) " .
                        "on duplicate key update `privileges` = ?",
                        array($mem_name,$type,join(',',$privs)));
  }
  //we're adding the privilege.
  elections_log(null,$mem_name,$member_name,
                user_privileges($mem_name),
                array_merge(user_privileges($mem_name),$type));
  return $db->Execute("insert into `privilege_table` (`member_name`," .
                      "`privileges`) values (?,?) " .
                      "on duplicate key update " .
                      "`privileges` = concat(`privileges`,?)",
                      array($mem_name,$type,",$type"));
}

//get member corresponding to the current session id, if it exists.
//the session id is stored in a table along with the member name and
//the expiration date.  Witnesses (see below) are also stored there.
function get_session_member() {
  global $db;
  //get rid of any expired sessions.
  $db->Execute("delete from `session_data` where `expiration` <= now()");
  //is there a session the user thinks they have?
  if (isset($_REQUEST['session_id'])) {
    $row = $db->GetRow("select `member_name` from `session_data` " .
                       "where `session_id` = ?",
                       array($_REQUEST['session_id']));
    //we don't have that session.
    if (is_empty($row)) {
      return null;
    }
    //we have it.  Give back the member name.
    return $row['member_name'];
  }
  return null;
}

//set the current session id.
function set_session($member_name) {
  global $db;
  //we don't want this to succeed partially, since then someone gets
  //locked out, even though they were going to be authenticated.
  $db->Execute("lock tables `session_data` write");
  $db->StartTrans();
  //get rid of any old session ids
  $db->Execute("delete from `session_data` where `member_name` = ?",
               array($member_name));
  //unique session id.  the member_name is so I can track it easily
  $session_id = time() . $member_name . rand();
  //expires 1 hour from now
  $db->Execute("insert into `session_data` " .
               "(`member_name`,`session_id`,`expiration`) values " .
               "(?,?,addtime(now(),'01:00:00'))",
               array($member_name,$session_id));
  //give user the cookie
  setcookie('session_id',$session_id,time()+3600,"/");
  $db->CompleteTrans();
  $db->Execute("unlock tables");
}

//buried down here is the user authentication.  The logic is as
//follows: the secured part of the site was already secured by apache.
//An individual script can set $require_user to false to not require a
//user.  Otherwise, a valid user is required for every page.  Pages
//can fine-tune the requirements with the $require_user variable.
//Note that this function sets global variables that probably should
//not be set like this.  Oh well.  Best programming practices my ass.
//If $require_user is 'ok_nouser' then require_user won't crap out if
//there isn't a valid user, but will set the session if there is one.
//Useful occasionally.
function require_user($type = null,$mem_name=null,$passwd=null) {
  global $db, $baseurl,$php_includes,$secured,
    $member_name,$basedir,$body_insert,$require_user, $secured;
  //do we not need a user?
  if ($secured || (isset($require_user) && $require_user === false)) {
    return true;
  }
  //we just set a global variable!  Awesome!
  $member_name = $mem_name;
  //I rarely call require_user with an argument, so here's where
  //member_name gets set for real.
  if (!$member_name && isset($_REQUEST['member_name'])) {
    $member_name = $_REQUEST['member_name'];
  }
  //here's the member_name we thought we had.
  $session_member = get_session_member();
  //discrepancy, or didn't have a session_member?
  if (!$session_member || ($member_name && 
                           $member_name != $session_member)) {
    //authenticate afresh.
    $pass_check = check_passwd($member_name,$passwd);
    //does it really matter if we don't have a user?
    if ($require_user !== 'ok_nouser') {
      //not allowed to not have a password!
      if ($pass_check == -1) {
        //we'll offer a link to get back here later.
        exit("You have no password set.  <a href='" .
             escape_html($baseurl . '/set_passwd.php?&member_name=' .
                         $member_name . '&previous_url=' . $_SERVER['REQUEST_URI']) . 
             "'>Set your password</a>.");
      }
      //unsuccessful authentication.  Put up the auth page again.
      if ($pass_check <= 0) {
        require_once($php_includes . "/common/member_check.php");
        exit;
      }
    }
    //didn't really matter if we didn't have a user.  
    else if ($pass_check <= 0) {
      $member_name = null;
      return false;
    }
    //got all the way here?  We have a session!
    set_session($member_name);
  }
  else {
    //we already had a session
    $member_name = $session_member;
  }
  //here's the logout button -- don't print it yet, because maybe the
  //page is doing funky stuff and doesn't want output.
  $str = "<form action='" . escape_html($_SERVER['REQUEST_URI']) . 
    "' method=post><input type=hidden name='forget_login'>" .
    "<input type=submit value='Logout'></form>";
  //how the page tells us if output is not ok -- it sets $body_insert
  if (!isset($body_insert)) {
    print $str;
  }
  else {
    $body_insert .= $str;
  }
  //was this an ordinary require_user, or was the page asking if the
  //user had a certain privilege?
  if (!$type) {
    return true;
  }
  //if it's just one privilege, do they have it?
  if (!is_array($type)) {
    return authorized_user($member_name,$type);
  }
  //if it's more than one, how many do they have of them?
  return count(array_intersect(user_privileges($member_name),$type));
}
    
//some things, mostly in elections, require witnesses -- authenticated
//members of the house.  They're stored in sessions too.
//num is how many witnesses are needed.
function require_witnesses($num = 1) {
  global $db, $member_name, $php_includes;
  //do we already have witnesses?
  $witnesses = get_session_witness();
  if ($witnesses && count($witnesses) >= $num) {
    return $witnesses;
  }
  //we loop through, adding witnesses
  $witnesses = array();
  for ($ii = 0; $ii < $num; $ii++) {
    if (!isset($_REQUEST["member_witness_$ii"])) { 
      require_once("$php_includes/common/witness_check.php");
      exit;
    }
    $witness_name = $_REQUEST["member_witness_$ii"];
    //people can't witness themselves, and no duplicates allowed!
    //of course, password has to check
    if ($witness_name == $member_name ||
        in_array($witness_name,$witnesses) ||
        !isset($_REQUEST["passwd_witness_$ii"]) ||
        check_passwd($witness_name,$_REQUEST["passwd_witness_$ii"]) <= 0) {
      require_once("$php_includes/common/witness_check.php");
      exit;
    }
    $witnesses[] = $witness_name;
  }
  create_session_witness($witnesses);
  return $witnesses;
}

//get all the witnesses for this session.
function get_session_witness() {
  global $db, $member_name;
  $db->Execute("delete from `session_data` where `expiration` <= now()");
  if (isset($_REQUEST['session_id'])) {
    $row = $db->GetRow("select `witnesses` from `session_data` " .
                       "where `member_name` = ? and `session_id` = ?",
                       array($member_name,$_REQUEST['session_id'])); 
    if (is_empty($row) || !$row['witnesses']) {
      return null;
    }
    //since it's an array, it was stored serialized.
    return unserialize($row['witnesses']);
  }
  return null;
}

function create_session_witness($witnesses) {
  global $db, $member_name;
  $db->Execute("lock tables `session_data` write");
  $db->StartTrans();
  $db->Execute("update `session_data` set `witnesses` = ? where " .
               "`member_name` = ?",array(serialize($witnesses),
                                         $member_name));
  $db->CompleteTrans();
  $db->Execute("unlock tables");
}

//just returns necessary command to make whitespace break appropriately
function white_space_css() {
  $browser = browser_detection('full');
  switch ($browser[0]) {
  case 'moz':
    return "white-space: -moz-pre-wrap";
    break;
  case 'op':
    $ret = "white-space: -";
    if ($browser[9]>=7) {
      $ret .= "o-";
    }
    return $ret . "pre-wrap";
    break;
  case 'ie':
  case 'ie5x':
    if ($browser[9] > 5.5) {
      return "word-wrap: break-word";
    }
    break;
  default:
    return "white-space: pre-wrap";
  }
}


//function copied from:
//http://techpatterns.com/downloads/php_browser_detection.php
function browser_detection( $which_test ) {
  static $dom_browser, $safe_browser, $browser_user_agent, $os, $browser_name, $s_browser, $ie_version, 
    $version_number, $os_number, $b_repeat, $moz_version, $moz_version_number, $moz_rv, $moz_rv_full, $moz_release, 
    $type, $math_version_number;
  
  if ( !$b_repeat )
    {
      //initialize all variables with default values to prevent error
      $dom_browser = false;
      $type = 'bot';// default to bot since you never know with bots
      $safe_browser = false;
      $os = '';
      $os_number = '';
      $a_os_data = '';
      $browser_name = '';
      $version_number = '';
      $math_version_number = '';
      $ie_version = '';
      $moz_version = '';
      $moz_version_number = '';
      $moz_rv = '';
      $moz_rv_full = '';
      $moz_release = '';
      $b_success = false;// boolean for if browser found in main test
      
      //make navigator user agent string lower case to make sure all versions get caught
      // isset protects against blank user agent failure
      $browser_user_agent = ( isset( $_SERVER['HTTP_USER_AGENT'] ) ) ? strtolower( $_SERVER['HTTP_USER_AGENT'] ) : '';
      
      /*
		pack the browser type array, in this order
		the order is important, because opera must be tested first, then omniweb [which has safari data in string],
		same for konqueror, then safari, then gecko, since safari navigator user agent id's with 'gecko' in string.
		note that $dom_browser is set for all  modern dom browsers, this gives you a default to use.

		array[0] = id string for useragent, array[1] is if dom capable, array[2] is working name for browser, 
		array[3] identifies navigator useragent type

		Note: all browser strings are in lower case to match the strtolower output, this avoids possible detection
		errors

		Note: There are currently 5 navigator user agent types: 
		bro - modern, css supporting browser.
		bbro - basic browser, text only, table only, defective css implementation
		bot - search type spider
		dow - known download agent
		lib - standard http libraries
		*/
		// known browsers, list will be updated routinely, check back now and then
      $a_browser_types[] = array( 'opera', true, 'op', 'bro' );
      $a_browser_types[] = array( 'omniweb', true, 'omni', 'bro' );// mac osx browser, now uses khtml engine:
      $a_browser_types[] = array( 'msie', true, 'ie', 'bro' );
      $a_browser_types[] = array( 'konqueror', true, 'konq', 'bro' );
      $a_browser_types[] = array( 'safari', true, 'saf', 'bro' );
      // covers Netscape 6-7, K-Meleon, Most linux versions, uses moz array below
      $a_browser_types[] = array( 'gecko', true, 'moz', 'bro' );
      $a_browser_types[] = array( 'netpositive', false, 'netp', 'bbro' );// beos browser
      $a_browser_types[] = array( 'lynx', false, 'lynx', 'bbro' ); // command line browser
      $a_browser_types[] = array( 'elinks ', false, 'elinks', 'bbro' ); // new version of links
      $a_browser_types[] = array( 'elinks', false, 'elinks', 'bbro' ); // alternate id for it
      $a_browser_types[] = array( 'links ', false, 'links', 'bbro' ); // old name for links
      $a_browser_types[] = array( 'links', false, 'links', 'bbro' ); // alternate id for it
      $a_browser_types[] = array( 'w3m', false, 'w3m', 'bbro' ); // open source browser, more features than lynx/links
      $a_browser_types[] = array( 'webtv', false, 'webtv', 'bbro' );// junk ms webtv
      $a_browser_types[] = array( 'amaya', false, 'amaya', 'bbro' );// w3c browser
      $a_browser_types[] = array( 'dillo', false, 'dillo', 'bbro' );// linux browser, basic table support
      $a_browser_types[] = array( 'ibrowse', false, 'ibrowse', 'bbro' );// amiga browser
      $a_browser_types[] = array( 'icab', false, 'icab', 'bro' );// mac browser 
      $a_browser_types[] = array( 'crazy browser', true, 'ie', 'bro' );// uses ie rendering engine
      $a_browser_types[] = array( 'sonyericssonp800', false, 'sonyericssonp800', 'bbro' );// sony ericsson handheld
      
      // search engine spider bots:
      $a_browser_types[] = array( 'googlebot', false, 'google', 'bot' );// google 
      $a_browser_types[] = array( 'mediapartners-google', false, 'adsense', 'bot' );// google adsense
      $a_browser_types[] = array( 'yahoo-verticalcrawler', false, 'yahoo', 'bot' );// old yahoo bot
      $a_browser_types[] = array( 'yahoo! slurp', false, 'yahoo', 'bot' ); // new yahoo bot 
      $a_browser_types[] = array( 'yahoo-mm', false, 'yahoomm', 'bot' ); // gets Yahoo-MMCrawler and Yahoo-MMAudVid bots
      $a_browser_types[] = array( 'inktomi', false, 'inktomi', 'bot' ); // inktomi bot
      $a_browser_types[] = array( 'slurp', false, 'inktomi', 'bot' ); // inktomi bot
      $a_browser_types[] = array( 'fast-webcrawler', false, 'fast', 'bot' );// Fast AllTheWeb
      $a_browser_types[] = array( 'msnbot', false, 'msn', 'bot' );// msn search 
      $a_browser_types[] = array( 'ask jeeves', false, 'ask', 'bot' ); //jeeves/teoma
      $a_browser_types[] = array( 'teoma', false, 'ask', 'bot' );//jeeves teoma
      $a_browser_types[] = array( 'scooter', false, 'scooter', 'bot' );// altavista 
      $a_browser_types[] = array( 'openbot', false, 'openbot', 'bot' );// openbot, from taiwan
      $a_browser_types[] = array( 'ia_archiver', false, 'ia_archiver', 'bot' );// ia archiver
      $a_browser_types[] = array( 'zyborg', false, 'looksmart', 'bot' );// looksmart 
      $a_browser_types[] = array( 'almaden', false, 'ibm', 'bot' );// ibm almaden web crawler 
      $a_browser_types[] = array( 'baiduspider', false, 'baidu', 'bot' );// Baiduspider asian search spider
      $a_browser_types[] = array( 'psbot', false, 'psbot', 'bot' );// psbot image crawler 
      $a_browser_types[] = array( 'gigabot', false, 'gigabot', 'bot' );// gigabot crawler 
      $a_browser_types[] = array( 'naverbot', false, 'naverbot', 'bot' );// naverbot crawler, bad bot, block
      $a_browser_types[] = array( 'surveybot', false, 'surveybot', 'bot' );// 
      $a_browser_types[] = array( 'boitho.com-dc', false, 'boitho', 'bot' );//norwegian search engine 
      $a_browser_types[] = array( 'objectssearch', false, 'objectsearch', 'bot' );// open source search engine
      $a_browser_types[] = array( 'answerbus', false, 'answerbus', 'bot' );// http://www.answerbus.com/, web questions
		$a_browser_types[] = array( 'sohu-search', false, 'sohu', 'bot' );// chinese media company, search component
		$a_browser_types[] = array( 'iltrovatore-setaccio', false, 'il-set', 'bot' );

		// various http utility libaries 
		$a_browser_types[] = array( 'w3c_validator', false, 'w3c', 'lib' ); // uses libperl, make first
		$a_browser_types[] = array( 'wdg_validator', false, 'wdg', 'lib' ); // 
		$a_browser_types[] = array( 'libwww-perl', false, 'libwww-perl', 'lib' ); 
		$a_browser_types[] = array( 'jakarta commons-httpclient', false, 'jakarta', 'lib' );
		$a_browser_types[] = array( 'python-urllib', false, 'python-urllib', 'lib' ); 
		
		// download apps 
		$a_browser_types[] = array( 'getright', false, 'getright', 'dow' );
		$a_browser_types[] = array( 'wget', false, 'wget', 'dow' );// open source downloader, obeys robots.txt

		// netscape 4 and earlier tests, put last so spiders don't get caught
		$a_browser_types[] = array( 'mozilla/4.', false, 'ns', 'bbro' );
		$a_browser_types[] = array( 'mozilla/3.', false, 'ns', 'bbro' );
		$a_browser_types[] = array( 'mozilla/2.', false, 'ns', 'bbro' );
		
		//$a_browser_types[] = array( '', false ); // browser array template

		/* 
		moz types array
		note the order, netscape6 must come before netscape, which  is how netscape 7 id's itself.
		rv comes last in case it is plain old mozilla 
		*/
		$moz_types = array( 'firebird', 'phoenix', 'firefox', 'galeon', 'k-meleon', 'camino', 'epiphany', 
		'netscape6', 'netscape', 'multizilla', 'rv' );

		/*
		run through the browser_types array, break if you hit a match, if no match, assume old browser
		or non dom browser, assigns false value to $b_success.
		*/
		for ($i = 0; $i < count($a_browser_types); $i++)
		{
			//unpacks browser array, assigns to variables
			$s_browser = $a_browser_types[$i][0];// text string to id browser from array

			if (stristr($browser_user_agent, $s_browser)) 
			{
				// it defaults to true, will become false below if needed
				// this keeps it easier to keep track of what is safe, only 
				//explicit false assignment will make it false.
				$safe_browser = true;

				// assign values based on match of user agent string
				$dom_browser = $a_browser_types[$i][1];// hardcoded dom support from array
				$browser_name = $a_browser_types[$i][2];// working name for browser
				$type = $a_browser_types[$i][3];// sets whether bot or browser

				switch ( $browser_name )
				{
					// this is modified quite a bit, now will return proper netscape version number
					// check your implementation to make sure it works
					case 'ns':
						$safe_browser = false;
						$version_number = browser_version( $browser_user_agent, 'mozilla' );
						break;
					case 'moz':
						/*
						note: The 'rv' test is not absolute since the rv number is very different on 
						different versions, for example Galean doesn't use the same rv version as Mozilla, 
						neither do later Netscapes, like 7.x. For more on this, read the full mozilla numbering 
						conventions here:
						http://www.mozilla.org/releases/cvstags.html
						*/

						// this will return alpha and beta version numbers, if present
						$moz_rv_full = browser_version( $browser_user_agent, 'rv' );
						// this slices them back off for math comparisons
						$moz_rv = substr( $moz_rv_full, 0, 3 );

						// this is to pull out specific mozilla versions, firebird, netscape etc..
						for ( $i = 0; $i < count( $moz_types ); $i++ )
						{
							if ( stristr( $browser_user_agent, $moz_types[$i] ) ) 
							{
								$moz_version = $moz_types[$i];
								$moz_version_number = browser_version( $browser_user_agent, $moz_version );
								break;
							}
						}
						// this is necesary to protect against false id'ed moz'es and new moz'es.
						// this corrects for galeon, or any other moz browser without an rv number
						if ( !$moz_rv ) 
						{ 
							$moz_rv = substr( $moz_version_number, 0, 3 ); 
							$moz_rv_full = $moz_version_number; 
							/* 
							// you can use this instead if you are running php >= 4.2
							$moz_rv = floatval( $moz_version_number ); 
							$moz_rv_full = $moz_version_number;
							*/
						}
						// this corrects the version name in case it went to the default 'rv' for the test
						if ( $moz_version == 'rv' ) 
						{
							$moz_version = 'mozilla';
						}
						
						//the moz version will be taken from the rv number, see notes above for rv problems
						$version_number = $moz_rv;
						// gets the actual release date, necessary if you need to do functionality tests
						$moz_release = browser_version( $browser_user_agent, 'gecko/' );
						/* 
						Test for mozilla 0.9.x / netscape 6.x
						test your javascript/CSS to see if it works in these mozilla releases, if it does, just default it to:
						$safe_browser = true;
						*/
						if ( ( $moz_release < 20020400 ) || ( $moz_rv < 1 ) )
						{
							$safe_browser = false;
						}
						break;
					case 'ie':
						$version_number = browser_version( $browser_user_agent, $s_browser );
						// first test for IE 5x mac, that's the most problematic IE out there
						if ( stristr( $browser_user_agent, 'mac') )
						{
							$ie_version = 'ieMac';
						}
						// this assigns a general ie id to the $ie_version variable
						elseif ( $version_number >= 5 )
						{
							$ie_version = 'ie5x';
						}
						elseif ( ( $version_number > 3 ) && ( $version_number < 5 ) )
						{
							$dom_browser = false;
							$ie_version = 'ie4';
							// this depends on what you're using the script for, make sure this fits your needs
							$safe_browser = true; 
						}
						else
						{
							$ie_version = 'old';
							$dom_browser = false;
							$safe_browser = false; 
						}
						break;
					case 'op':
						$version_number = browser_version( $browser_user_agent, $s_browser );
						if ( $version_number < 5 )// opera 4 wasn't very useable.
						{
							$safe_browser = false; 
						}
						break;
					case 'saf':
						$version_number = browser_version( $browser_user_agent, $s_browser );
						break;
					/* 
						Uncomment this section if you want omniweb to return the safari value
						Omniweb uses khtml/safari rendering engine, so you can treat it like
						safari if you want.
					*/
					/* 
					case 'omni':
						$s_browser = 'safari';
						$browser_name = 'saf';
						$version_number = browser_version( $browser_user_agent, 'applewebkit' );
						break; 
					*/
					default:
						$version_number = browser_version( $browser_user_agent, $s_browser );
						break;
				}
				// the browser was id'ed
				$b_success = true;
				break;
			}
		}
		
		//assigns defaults if the browser was not found in the loop test
		if ( !$b_success ) 
		{
			/*
				this will return the first part of the browser string if the above id's failed
				usually the first part of the browser string has the navigator useragent name/version in it.
				This will usually correctly id the browser and the browser number if it didn't get
				caught by the above routine.
				If you want a '' to do a if browser == '' type test, just comment out all lines below
				except for the last line, and uncomment the last line. If you want undefined values, 
				the browser_name is '', you can always test for that
			*/
			// delete this part if you want an unknown browser returned
			$s_browser = substr( $browser_user_agent, 0, strcspn( $browser_user_agent , '();') );
			// this extracts just the browser name from the string
			ereg('[^0-9][a-z]*-*\ *[a-z]*\ *[a-z]*', $s_browser, $r );
			$s_browser = $r[0];
			$version_number = browser_version( $browser_user_agent, $s_browser );

			// then uncomment this part
			//$s_browser = '';//deletes the last array item in case the browser was not a match
		}
		// get os data, mac os x test requires browser/version information, this is a change from older scripts
		$a_os_data = which_os( $browser_user_agent, $browser_name, $version_number );
		$os = $a_os_data[0];// os name, abbreviated
		$os_number = $a_os_data[1];// os number or version if available

		// this ends the run through once if clause, set the boolean 
		//to true so the function won't retest everything
		$b_repeat = true;

		// pulls out primary version number from more complex string, like 7.5a, 
		// use this for numeric version comparison
		$m = array();
		if ( ereg('[0-9]*\.*[0-9]*', $version_number, $m ) )
		{
			$math_version_number = $m[0]; 
			//print_r($m);
		}
		
	}
	//$version_number = $_SERVER["REMOTE_ADDR"];
	/*
	This is where you return values based on what parameter you used to call the function
	$which_test is the passed parameter in the initial browser_detection('os') for example call
	*/
	switch ( $which_test )
	{
		case 'safe':// returns true/false if your tests determine it's a safe browser
			// you can change the tests to determine what is a safeBrowser for your scripts
			// in this case sub rv 1 Mozillas and Netscape 4x's trigger the unsafe condition
			return $safe_browser; 
			break;
		case 'ie_version': // returns ieMac or ie5x
			return $ie_version;
			break;
		case 'moz_version':// returns array of all relevant moz information
			$moz_array = array( $moz_version, $moz_version_number, $moz_rv, $moz_rv_full, $moz_release );
			return $moz_array;
			break;
		case 'dom':// returns true/fale if a DOM capable browser
			return $dom_browser;
			break;
		case 'os':// returns os name
			return $os; 
			break;
		case 'os_number':// returns os number if windows
			return $os_number;
			break;
		case 'browser':// returns browser name
			return $browser_name; 
			break;
		case 'number':// returns browser number
			return $version_number;
			break;
		case 'full':// returns all relevant browser information in an array
			$full_array = array( $browser_name, $version_number, $ie_version, $dom_browser, $safe_browser, 
				$os, $os_number, $s_browser, $type, $math_version_number );
			return $full_array;
			break;
		case 'type':// returns what type, bot, browser, maybe downloader in future
			return $type;
			break;
		case 'math_number':// returns numerical version number, for number comparisons
			return $math_version_number;
			break;
		default:
			break;
	}
}

// gets which os from the browser string
function which_os ( $browser_string, $browser_name, $version_number  )
{
	// initialize variables
	$os = '';
	$os_version = '';
	/*
	packs the os array
	use this order since some navigator user agents will put 'macintosh' in the navigator user agent string
	which would make the nt test register true
	*/
	$a_mac = array( 'mac68k', 'macppc' );// this is not used currently
	// same logic, check in order to catch the os's in order, last is always default item
	$a_unix = array( 'unixware', 'solaris', 'sunos', 'sun4', 'sun5', 'suni86', 'sun', 
		'freebsd', 'openbsd', 'bsd' , 'irix5', 'irix6', 'irix', 'hpux9', 'hpux10', 'hpux11', 'hpux', 'hp-ux', 
		'aix1', 'aix2', 'aix3', 'aix4', 'aix5', 'aix', 'sco', 'unixware', 'mpras', 'reliant',
		'dec', 'sinix', 'unix' );
	// only sometimes will you get a linux distro to id itself...
	$a_linux = array( 'kanotix', 'ubuntu', 'mepis', 'debian', 'suse', 'redhat', 'slackware', 'mandrake', 'gentoo', 'linux' );
	$a_linux_process = array ( 'i386', 'i586', 'i686' );// not use currently
	// note, order of os very important in os array, you will get failed ids if changed
	$a_os = array( 'beos', 'os2', 'amiga', 'webtv', 'mac', 'nt', 'win', $a_unix, $a_linux );

	//os tester
	for ( $i = 0; $i < count( $a_os ); $i++ )
	{
		//unpacks os array, assigns to variable
		$s_os = $a_os[$i];

		//assign os to global os variable, os flag true on success
		//!stristr($browser_string, "linux" ) corrects a linux detection bug
		if ( !is_array( $s_os ) && stristr( $browser_string, $s_os ) && !stristr( $browser_string, "linux" ) )
		{
			$os = $s_os;

			switch ( $os )
			{
				case 'win':
					if ( strstr( $browser_string, '95' ) )
					{
						$os_version = '95';
					}
					elseif ( ( strstr( $browser_string, '9x 4.9' ) ) || ( strstr( $browser_string, 'me' ) ) )
					{
						$os_version = 'me';
					}
					elseif ( strstr( $browser_string, '98' ) )
					{
						$os_version = '98';
					}
					elseif ( strstr( $browser_string, '2000' ) )// windows 2000, for opera ID
					{
						$os_version = 5.0;
						$os = 'nt';
					}
					elseif ( strstr( $browser_string, 'xp' ) )// windows 2000, for opera ID
					{
						$os_version = 5.1;
						$os = 'nt';
					}
					elseif ( strstr( $browser_string, '2003' ) )// windows server 2003, for opera ID
					{
						$os_version = 5.2;
						$os = 'nt';
					}
					elseif ( strstr( $browser_string, 'ce' ) )// windows CE
					{
						$os_version = 'ce';
					}
					break;
				case 'nt':
					if ( strstr( $browser_string, 'nt 5.2' ) )// windows server 2003
					{
						$os_version = 5.2;
						$os = 'nt';
					}
					elseif ( strstr( $browser_string, 'nt 5.1' ) || strstr( $browser_string, 'xp' ) )// windows xp
					{
						$os_version = 5.1;//
					}
					elseif ( strstr( $browser_string, 'nt 5' ) || strstr( $browser_string, '2000' ) )// windows 2000
					{
						$os_version = 5.0;
					}
					elseif ( strstr( $browser_string, 'nt 4' ) )// nt 4
					{
						$os_version = 4;
					}
					elseif ( strstr( $browser_string, 'nt 3' ) )// nt 4
					{
						$os_version = 3;
					}
					break;
				case 'mac':
					if ( strstr( $browser_string, 'os x' ) ) 
					{
						$os_version = 10;
					}
					//this is a crude test for os x, since safari, camino, ie 5.2, & moz >= rv 1.3 
					//are only made for os x
					elseif ( ( $browser_name == 'saf' ) || ( $browser_name == 'cam' ) || 
						( ( $browser_name == 'moz' ) && ( $version_number >= 1.3 ) ) || 
						( ( $browser_name == 'ie' ) && ( $version_number >= 5.2 ) ) )
					{
						$os_version = 10;
					}
					break;
				default:
					break;
			}
			break;
		}
		// check that it's an array, check it's the second to last item 
		//in the main os array, the unix one that is
		elseif ( is_array( $s_os ) && ( $i == ( count( $a_os ) - 2 ) ) )
		{
			for ($j = 0; $j < count($s_os); $j++)
			{
				if ( stristr( $browser_string, $s_os[$j] ) )
				{
					$os = 'unix'; //if the os is in the unix array, it's unix, obviously...
					$os_version = ( $s_os[$j] != 'unix' ) ? $s_os[$j] : '';// assign sub unix version from the unix array
					break;
				}
			}
		} 
		// check that it's an array, check it's the last item 
		//in the main os array, the linux one that is
		elseif ( is_array( $s_os ) && ( $i == ( count( $a_os ) - 1 ) ) )
		{
			for ($j = 0; $j < count($s_os); $j++)
			{
				if ( stristr( $browser_string, $s_os[$j] ) )
				{
					$os = 'lin';
					// assign linux distro from the linux array, there's a default
					//search for 'lin', if it's that, set version to ''
					$os_version = ( $s_os[$j] != 'linux' ) ? $s_os[$j] : '';
					break;
				}
			}
		} 
	}

	// pack the os data array for return to main function
	$os_data = array( $os, $os_version );
	return $os_data;
}

// function returns browser number, gecko rv number, or gecko release date
//function browser_version( $browser_user_agent, $search_string, $substring_length )
function browser_version( $browser_user_agent, $search_string )
{
	// 12 is the longest that will be required, handles release dates: 20020323; 0.8.0+
	$substring_length = 12;
	//initialize browser number, will return '' if not found
	$browser_number = '';

	// use the passed parameter for $search_string
	// start the substring slice right after these moz search strings
	// there are some cases of double msie id's, first in string and then with then number
	$start_pos = 0;  
	/* this test covers you for multiple occurrences of string, only with ie though
	 with for example google bot you want the first occurance returned, since that's where the
	numbering happens */
	
	for ( $i = 0; $i < 4; $i++ )
	{
		//start the search after the first string occurrence
		if ( strpos( $browser_user_agent, $search_string, $start_pos ) !== false )
		{
			//update start position if position found
			$start_pos = strpos( $browser_user_agent, $search_string, $start_pos ) + strlen( $search_string );
			if ( $search_string != 'msie' )
			{
				break;
			}
		}
		else 
		{
			break;
		}
	}

	// this is just to get the release date, not other moz information
	// also corrects for the omniweb 'v'
	if ( $search_string != 'gecko/' ) 
	{ 
		if ( $search_string == 'omniweb' )
		{
			$start_pos += 2;// handles the v in 'omniweb/v532.xx
		}
		else
		{
			$start_pos++; 
		}
	}

	// Initial trimming
	$browser_number = substr( $browser_user_agent, $start_pos, $substring_length );

	// Find the space, ;, or parentheses that ends the number
	$browser_number = substr( $browser_number, 0, strcspn($browser_number, ' );') );

	//make sure the returned value is actually the id number and not a string
	// otherwise return ''
	if ( !is_numeric( substr( $browser_number, 0, 1 ) ) )
	{ 
		$browser_number = ''; 
	}
	//$browser_number = strrpos( $browser_user_agent, $search_string );
	return $browser_number;
}

/* 
Here are some typical navigator.userAgent strings so you can see where the data comes from
Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.5) Gecko/20031007 Firebird/0.7 
Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:0.9.4) Gecko/20011128 Netscape6/6.2.1
*/

//currently unused.  It is supposed to be used so that users can
//save their settings of how a particular page is viewed -- how the
//columns are sorted, which columns are hidden, etc.  It would require
//a whole new module in table_edit.js to communicate this info back to
//the server.
//the attrib is page-specific, which is why the page name is
//specified.  the userconf_aux_key is something that might be
//request-specific, like the name of the user.  Too lazy to pass it
//each time to the function.
function get_userconf($attrib,$default_value = null, $page_name = null) {
  global $db,$archive,$userconf_aux_key;
  if (!$page_name) {
    $page_name = $_SERVER['SCRIPT_NAME'];
  }
  $arr = array($_SERVER['SCRIPT_NAME'],$attrib);
  if ($userconf_aux_key !== null) {
    $arr[] = $userconf_aux_key;
  }
  $row = $db->GetRow("select `attrib_value` from " .
                     bracket($archive . 'userconf_data') .
                     " where `page_name` = ? and `attrib_name` = ?" .
                     ($userconf_aux_key !== null?' and `aux_key` = ?':'') .
                     "limit 1 order by `autoid` desc",
                     $arr);
  if (is_empty($row)) {
    if ($default_value !== null) {
      set_userconf($attrib,$default_value,
                   $userconf_aux_key,$script_name);
    }
    return $default_value;
  }
  return $row['attrib_value'];
}

function set_userconf($attrib,$val,$page_name = null) {
  global $db,$archive,$userconf_aux_key;
  if (!$page_name) {
    $page_name = $_SERVER['SCRIPT_NAME'];
  }  
  return ($db->Execute('REPLACE INTO ' . 
		       bracket($archive . 'userconf_data') . 
		       ' (`page_name`,`aux_key`,`attrib_name`,' .
                       '`attrib_value`) ' .
                       'values (?,?,?,?)',
                       array($page_name,$userconf_aux_key,
                             $attrib,$val)));
}


?>
